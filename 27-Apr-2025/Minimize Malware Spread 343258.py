# Problem: Minimize Malware Spread - https://leetcode.com/problems/minimize-malware-spread/

# # class Solution:
# #     def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
# #         initial.sort()
# #         malware = set()
# #         def dfs(node, visited):
# #             nonlocal malware
# #             visited.add(node)
# #             malware.add(node)
# #             for vertex in graphs[node]:
# #                 if not vertex in visited and not vertex in malware:
# #                     dfs(vertex, visited)
# #             return len(visited)
# #         graphs = defaultdict(list)
# #         for i in range(len(graph)):
# #             for j in range(len(graph[0])):
# #                 if i != j and graph[i][j]:
# #                     graphs[i].append(j)
# #         node = initial[0]
# #         curr = 0
# #         for x in initial:
# #             visited = set()
# #             if x != node:
# #                 curr += dfs(x, visited)
# #         print(curr)
# #         print(graphs)
# #         n = len(graph)
# #         for x in initial:
# #             now = 0
# #             visited = set()
# #             for y in initial:
# #                 if x != y:
# #                     now += dfs(y, visited)
# #             unvisited = set()
# #             nex = 0
# #             for z in range(n):
# #                 if not z in visited or z != x:
# #                     nex += dfs(z, unvisited)
# #             now = nex

            
# #             if now > curr:
# #                 node = y
# #                 curr = now
                
# #         return node
# class Solution:
#     def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
#         def dfs(node, visited):
#             visited.add(node)
#             for vertex in graphs[node]:
#                 if not vertex in visited:
#                     dfs(vertex, visited)
#             return len(visited)
#         graphs = defaultdict(list)
#         total_vertex = set()
#         for i in range(len(graph)):
#             for j in range(len(graph[0])):
#                 if i != j and graph[i][j]:
#                     graphs[i].append(j)
#                     total_vertex.add(i)
#         print(graphs, len(total_vertex))
#         total_vertex_count = len(total_vertex)
#         node = initial[0]
#         curr = 0
#         for x in initial:
#             visited = set()
#             if x != node:
#                 curr += dfs(x, visited)
#         print(curr)
        
#         print("total = ",total_vertex_count)
#         print(graphs)
#         for x in initial:
#             now = 0
#             visited = set()
#             for y in initial:
#                 if x != y:
#                     now += dfs(y, visited)
#             now = len(total_vertex) - now
#             if now > curr:
#                 node = y
#                 curr = now
#             # print(visited, x)
                
#         return node

from collections import defaultdict
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        def dfs(node, visited, connected):
            visited.add(node)
            connected.append(node)
            for vertex in graphs[node]:
                if vertex not in visited:
                    dfs(vertex, visited, connected)
        
        graphs = defaultdict(list)
        n = len(graph)
        
        for i in range(n):
            graphs[i] 
        
        for i in range(n):
            for j in range(n):
                if i != j and graph[i][j]:
                    graphs[i].append(j)
        
        initial_set = set(initial)
        initial.sort()
        
        visited = set()
        res = (-1, initial[0])
        
        for node in initial:
            if node not in visited:
                connected = []
                dfs(node, visited, connected)
                
                infected_count = 0
                for x in connected:
                    if x in initial_set:
                        infected_count += 1
                
                if infected_count == 1:
                    saved = len(connected)
                    if saved > res[0]:
                        res = (saved, node)
                    elif saved == res[0] and node < res[1]:
                        res = (saved, node)
        
        return res[1]
